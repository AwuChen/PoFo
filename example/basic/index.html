<head> 
  <style> 
    body { margin: 0; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
</head>

<body>
  <div id="controls">
    <button onclick="setState(1)">State 1: Lines Only</button>
    <button onclick="setState(2)">State 2: + Grid</button>
    <button onclick="setState(3)">State 3: + Nodes</button>
  </div>
  <div id="graph"></div>

  <script>
    const N = 150, layers = 5;
    const nodes = [], links = [], layerNodeCounts = [];

    let nodeId = 0;
    for (let layer = 0; layer < layers; layer++) {
      const count = Math.round(N / layers);
      layerNodeCounts.push(count);
      for (let i = 0; i < count; i++) {
        const angle = (2 * Math.PI * i) / count;
        const radius = 100 + layer * 80;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);
        nodes.push({
          id: nodeId++,
          fx: x,
          fy: y,
          size: Math.random() * 6 + 2,
          color: ['#bc6c25', '#606c38', '#283618', '#dda15e', '#7b7b7b'][Math.floor(Math.random() * 5)]
        });
      }
    }

    let prevStart = 0;
    for (let l = 1; l < layers; l++) {
      const currStart = layerNodeCounts.slice(0, l).reduce((a, b) => a + b, 0);
      const currCount = layerNodeCounts[l], prevCount = layerNodeCounts[l - 1];
      for (let i = 0; i < currCount; i++) {
        links.push({ source: currStart + i, target: prevStart + (i % prevCount) });
      }
      prevStart = currStart;
    }

    const gData = { nodes, links };

    let highlightNode = null;
    let highlightLink = null;
    let currentState = 3;

    const Graph = ForceGraph()(document.getElementById('graph'))
      .graphData(gData)
      .enableNodeDrag(false)
      .nodeRelSize(0)
      .onEngineTick(() => Graph.pauseAnimation())
      .linkWidth(l =>
        l === highlightLink || l.source === highlightNode || l.target === highlightNode ? 2 : 1
      )
      .linkColor(l =>
        l === highlightLink || l.source === highlightNode || l.target === highlightNode ? '#f00' : '#999'
      )
      .onNodeHover(node => {
        highlightNode = node;
        highlightLink = null;
        Graph.graphData(gData); // trigger redraw
      })
      .onLinkHover(link => {
        highlightLink = link;
        highlightNode = null;
        Graph.graphData(gData); // trigger redraw
      })
      .nodeCanvasObject((node, ctx, globalScale) => {
        if (node.id === 0 && currentState >= 2) {
          const spacing = 80;
          ctx.save();
          ctx.strokeStyle = '#ccc';
          ctx.lineWidth = 1 / globalScale;
          for (let i = 0; i < layers; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, 100 + i * spacing, 0, 2 * Math.PI);
            ctx.stroke();
          }
          ctx.restore();
        }

        if (currentState < 3) return; // hide nodes in states 1 & 2

        const isHighlighted = node === highlightNode;
        ctx.beginPath();
        ctx.arc(node.x, node.y, node.size, 0, 2 * Math.PI);
        ctx.fillStyle = node.color;
        ctx.globalAlpha = isHighlighted ? 1 : 0.2;
        ctx.fill();
        ctx.globalAlpha = 1;
      });

    function setState(state) {
      currentState = state;
      highlightNode = null;
      highlightLink = null;
      Graph.graphData(gData); // reassign to force redraw
    }

    setState(3); // initial state
  </script>
</body>
