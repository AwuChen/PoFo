<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Radial Graph States</title>
  <style>
    body { margin: 0; font-family: sans-serif; background: #f4f4f4; }
    canvas { display: block; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0,0,0,0.2);
    }
    #controls button {
      margin: 5px;
      padding: 8px 12px;
      font-size: 14px;
    }
  </style>
</head>
<body>

<div id="controls">
  <button onclick="setGraphState(1)">State 1</button>
  <button onclick="setGraphState(2)">State 2</button>
  <button onclick="setGraphState(3)">State 3</button>
</div>

<canvas id="radial-graph"></canvas>

<script src="https://unpkg.com/force-graph"></script>
<script>
  const canvas = document.getElementById('radial-graph');
  const context = canvas.getContext('2d');
  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  const Graph = ForceGraph()(canvas)
    .nodeRelSize(4)
    .linkWidth(1)
    .nodeColor(node => node.color || '#333')
    .backgroundColor('#f4f4f4')
    .d3AlphaDecay(0.05)
    .nodeCanvasObjectMode(() => 'after');

  let showGrid = false;
  let state = 1;

  const numRadials = 36;
  const numRings = 7;
  const maxRadius = Math.min(width, height) / 2 - 50;
  const centerX = width / 2;
  const centerY = height / 2;

  const polarToCartesian = (r, angle) => {
    const rad = angle * (Math.PI / 180);
    return {
      x: centerX + r * Math.cos(rad),
      y: centerY + r * Math.sin(rad)
    };
  };

  // Build radial layout nodes
  const nodes = [];
  const links = [];

  for (let i = 0; i < numRadials; i++) {
    const angle = (360 / numRadials) * i;
    for (let j = 1; j <= numRings; j++) {
      const radius = (maxRadius / numRings) * j;
      const pos = polarToCartesian(radius, angle);
      const id = `${i}-${j}`;
      nodes.push({ id, fx: pos.x, fy: pos.y });

      if (j > 1) {
        const parentId = `${i}-${j - 1}`;
        links.push({ source: parentId, target: id });
      }
    }
  }

  Graph.width(width).height(height).graphData({ nodes, links });

  function drawGrid() {
    context.clearRect(0, 0, width, height);

    if (showGrid) {
      context.save();
      context.strokeStyle = '#999';
      context.lineWidth = 0.5;
      context.setLineDash([4, 4]);

      // Draw concentric circles
      for (let j = 1; j <= numRings; j++) {
        const r = (maxRadius / numRings) * j;
        context.beginPath();
        context.arc(centerX, centerY, r, 0, 2 * Math.PI);
        context.stroke();
      }

      context.restore();
    }

    // Always draw radial lines
    context.save();
    context.strokeStyle = '#999';
    context.lineWidth = 0.5;
    context.setLineDash([2, 2]);

    for (let i = 0; i < numRadials; i++) {
      const angle = (360 / numRadials) * i;
      const pos = polarToCartesian(maxRadius, angle);
      context.beginPath();
      context.moveTo(centerX, centerY);
      context.lineTo(pos.x, pos.y);
      context.stroke();
    }

    context.restore();
  }

  function getRandomColor() {
  const palette = ['#999', '#c55', '#6a6', '#95a', '#dd8'];
  return palette[Math.floor(Math.random() * palette.length)];
}

  function setGraphState(newState) {
    state = newState;
    switch (state) {
      case 1: // Only lines
        showGrid = false;
        Graph.nodeCanvasObject(() => {});
        Graph.enableNodeDrag(false);
        drawGrid();
        break;

      case 2: // Lines + grid
        showGrid = true;
        Graph.nodeCanvasObject(() => {});
        Graph.enableNodeDrag(false);
        drawGrid();
        break;

      case 3: // Grid + radial links + nodes
  showGrid = true;
  drawGrid();

  // Reposition nodes in radial layout
  nodes.forEach((node, i) => {
    const angle = (i / nodes.length) * 2 * Math.PI;
    const radius = 200 + Math.random() * 100;
    node.fx = radius * Math.cos(angle);
    node.fy = radius * Math.sin(angle);
    node.x = node.fx;
    node.y = node.fy;
    node.color = node.color || getRandomColor(); // Assign if not set
    node.val = node.val || 5;
  });

  Graph
    .graphData({ nodes: [...nodes], links })
    .nodeCanvasObject((node, ctx) => {
      const r = node.val || 4;
      ctx.beginPath();
      ctx.arc(node.x, node.y, r, 0, 2 * Math.PI, false);
      ctx.fillStyle = node.color || '#000';
      ctx.fill();
    })
    .enableNodeDrag(false);
  break;


    }
  }

  setGraphState(1); // Initial state

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    Graph.width(width).height(height);
    drawGrid();
  });
</script>
</body>
</html>
