<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Radial Impact Graph</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas {
      position: absolute;
      top: 0;
      left: 0;
    }
    #impactRingsCanvas {
      z-index: 0;
    }
    #graph canvas {
      z-index: 1;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 12px;
      border-radius: 10px;
      font-family: sans-serif;
      font-size: 14px;
      max-width: 240px;
    }
    #controls h4 {
      margin: 10px 0 5px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
</head>
<body>

<canvas id="impactRingsCanvas"></canvas>
<div id="graph"></div>

<div id="controls">
  <h4>PORTFOLIO & CATEGORIES</h4>
  <div id="categoryFilters"></div>
  <h4>IMPACT</h4>
  <div id="impactFilters"></div>
</div>

<script>
  const projects = [
    { name: 'URF / TX The BOX', category: 'Investment', impacts: ['Retail'] },
    { name: 'SAUVEREIGN', category: 'Forces', impacts: ['Branding', 'Retail'] },
    { name: 'DONGHAI', category: 'Consultancies', impacts: ['East.West', 'Strategy.Culture'] },
    { name: 'EASTERN SEAS', category: 'Consultancies', impacts: ['East.West'] },
    { name: 'DANDELION', category: 'Cities.culture.art', impacts: ['Creative Solution'] },
    { name: 'BILI Q', category: 'Yesteryears', impacts: ['Edu.Learning.Collective'] },
    { name: 'KYOTO ART BANK', category: 'Ecosystems', impacts: ['Edu.Learning.Collective'] },
    { name: 'ARAMIS WINES', category: 'Investment', impacts: ['Branding', 'Retail'] }
  ];

  const impactRingMap = {
    'Strategy.Culture': 0,
    'Branding': 1,
    'Retail': 2,
    'East.West': 3,
    'Edu.Learning.Collective': 4,
    'Creative Solution': 5
  };

  const ringColors = ['#bc6c25', '#dda15e', '#f4a261', '#e76f51', '#2a9d8f', '#264653'];
  const baseRadius = 100;
  const ringSpacing = 60;

  const radialCount = projects.length;
  const nodes = [], links = [];
  let nodeId = 0;

  const centerNodeId = nodeId++;
  nodes.push({ id: centerNodeId, fx: 0, fy: 0, size: 4, color: '#000' });

  projects.forEach((proj, i) => {
    const angle = (2 * Math.PI * i) / radialCount;
    const name = proj.name;

    let lastNodeId = centerNodeId;

    proj.impacts.forEach(impact => {
      const ringIndex = impactRingMap[impact];
      const radius = baseRadius + ringIndex * ringSpacing;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);

      const thisNodeId = nodeId++;
      nodes.push({
        id: thisNodeId,
        fx: x,
        fy: y,
        radialIndex: i,
        impact,
        category: proj.category,
        project: name,
        color: ringColors[ringIndex % ringColors.length],
        size: 6
      });

      links.push({
        source: lastNodeId,
        target: thisNodeId,
        radialIndex: i,
        project: name,
        category: proj.category,
        impact
      });

      lastNodeId = thisNodeId;
    });
  });

  const gData = { nodes, links };
  let activeRadial = null;

  const Graph = ForceGraph()(document.getElementById('graph'))
    .graphData(gData)
    .enableNodeDrag(false)
    .onEngineTick(() => Graph.pauseAnimation())
    .linkWidth(link => (link.radialIndex === activeRadial ? 2 : 1))
    .linkColor(link => (link.radialIndex === activeRadial ? '#222' : '#aaa'))
    .onNodeHover(node => {
      activeRadial = node ? node.radialIndex : null;
      Graph.graphData(filteredGraphData());
    })
    .nodeCanvasObject((node, ctx, globalScale) => {
      if (node.id === centerNodeId) return;
      const isHighlighted = node.radialIndex === activeRadial;
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.size, 0, 2 * Math.PI);
      ctx.fillStyle = node.color;
      ctx.globalAlpha = isHighlighted || activeRadial === null ? 1 : 0.1;
      ctx.fill();
      ctx.globalAlpha = 1;
    });

  // Draw static impact rings
  const ringCanvas = document.getElementById('impactRingsCanvas');
  const ringCtx = ringCanvas.getContext('2d');

  function drawImpactRings() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    ringCanvas.width = width;
    ringCanvas.height = height;
    ringCtx.clearRect(0, 0, width, height);
    ringCtx.translate(width / 2, height / 2);

    Object.entries(impactRingMap).forEach(([impact, ringIndex]) => {
      const radius = baseRadius + ringIndex * ringSpacing;
      ringCtx.beginPath();
      ringCtx.arc(0, 0, radius, 0, 2 * Math.PI);
      ringCtx.lineWidth = 1.5;
      ringCtx.strokeStyle = ringColors[ringIndex % ringColors.length];
      ringCtx.stroke();
    });

    ringCtx.setTransform(1, 0, 0, 1, 0, 0);
  }

  window.addEventListener('resize', drawImpactRings);
  drawImpactRings();

  // Filters
  const categories = [...new Set(projects.map(p => p.category))];
  const impacts = Object.keys(impactRingMap);
  const selectedCategories = new Set(categories);
  const selectedImpacts = new Set(impacts);

  function createCheckboxes(list, containerId, selectedSet) {
    const container = document.getElementById(containerId);
    list.forEach(label => {
      const id = `${containerId}_${label.replace(/\W+/g, '')}`;
      const box = document.createElement('input');
      box.type = 'checkbox';
      box.id = id;
      box.checked = true;
      box.onchange = () => {
        if (box.checked) selectedSet.add(label);
        else selectedSet.delete(label);
        Graph.graphData(filteredGraphData());
      };
      const lbl = document.createElement('label');
      lbl.htmlFor = id;
      lbl.textContent = ' ' + label;
      const div = document.createElement('div');
      div.appendChild(box);
      div.appendChild(lbl);
      container.appendChild(div);
    });
  }

  function filteredGraphData() {
    const filteredNodes = nodes.filter(
      n => n.id === centerNodeId ||
      (selectedCategories.has(n.category) && n.impact && selectedImpacts.has(n.impact))
    );
    const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
    const filteredLinks = links.filter(
      l => filteredNodeIds.has(l.source) && filteredNodeIds.has(l.target)
    );
    return { nodes: filteredNodes, links: filteredLinks };
  }

  createCheckboxes(categories, 'categoryFilters', selectedCategories);
  createCheckboxes(impacts, 'impactFilters', selectedImpacts);
</script>

</body>
</html>
