<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Radial Graph with Categories & Impacts</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }
    #controls, #filter-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.9);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
    }
    #filter-panel {
      top: 130px;
      max-width: 250px;
    }
    #filter-panel label {
      display: block;
      margin-bottom: 4px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
</head>
<body>

  <div id="filter-panel">
    <strong>PORTFOLIO & CATEGORIES</strong><br>
    <div id="category-filters"></div>
    <br>
    <strong>APPROACH & IMPACT</strong><br>
    <div id="impact-filters"></div>
  </div>

  <div id="graph"></div>

  <script>
    const baseRadius = 100;
    const ringSpacing = 80;
    const ringColors = ['#bc6c25', '#606c38', '#283618', '#dda15e', '#7b7b7b'];
    const allCategories = ['Investment', 'Forces', 'Consultancies', 'Cities.culture.art', 'Ecosystems', 'Yesteryears'];
    const allImpacts = ['Strategy.Culture', 'Branding', 'Retail', 'East.West', 'Edu.Learning.Collective', 'Creative Solution'];

    const radialLines = [
      { name: 'URF / TX The BOX', categories: ['Investment'], impacts: ['Retail'] },
      { name: 'SAUVEREIGN', categories: ['Consultancies'], impacts: ['Branding'] },
      { name: 'DONGHAI', categories: ['Forces'], impacts: ['East.West', 'Strategy.Culture'] },
      { name: 'EASTERN SEAS', categories: ['Cities.culture.art'], impacts: ['Creative Solution'] },
      { name: 'DANDELION', categories: ['Ecosystems'], impacts: ['Edu.Learning.Collective'] },
      { name: 'BILI Q', categories: ['Yesteryears'], impacts: ['Retail', 'Branding'] },
      { name: 'KYOTO ART BANK', categories: ['Investment', 'Cities.culture.art'], impacts: ['Strategy.Culture'] },
      { name: 'ARAMIS WINES', categories: ['Forces'], impacts: ['East.West', 'Branding'] }
    ];

    const nodes = [], links = [];
    let nodeId = 0;

    const centerNodeId = nodeId++;
    nodes.push({
      id: centerNodeId,
      fx: 0,
      fy: 0,
      size: 4,
      color: '#000000'
    });

    radialLines.forEach((line, i) => {
      let lastNodeId = centerNodeId;
      const angle = (2 * Math.PI * i) / radialLines.length;

      line.impacts.forEach(impact => {
        const layer = allImpacts.indexOf(impact); // map each impact to a ring index
        const radius = baseRadius + layer * ringSpacing;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);

        const node = {
          id: nodeId,
          fx: x,
          fy: y,
          radialIndex: i,
          name: line.name,
          categories: line.categories,
          impacts: line.impacts,
          size: 6,
          color: ringColors[layer % ringColors.length]
        };

        nodes.push(node);
        links.push({ source: lastNodeId, target: nodeId });
        lastNodeId = nodeId;
        nodeId++;
      });
    });

    const gData = { nodes, links };
    let currentState = 3;
    let activeRadial = null;

    const Graph = ForceGraph()(document.getElementById('graph'))
    .graphData(gData)
    .enableNodeDrag(false)
    .onEngineTick(() => Graph.pauseAnimation())
    .linkWidth(link => currentState === 2 ? 1 : 1)
    .linkColor(() => '#aaa')
    .onNodeHover(node => {
      activeRadial = node ? node.radialIndex : null;
        Graph.graphData(Graph.graphData()); // refresh
      })
    .nodeCanvasObject((node, ctx, globalScale) => {
      if (node.id === 0 && currentState >= 2) {
        ctx.save();
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1 / globalScale;
        for (let i = 0; i < allImpacts.length; i++) {
          ctx.beginPath();
          ctx.arc(0, 0, baseRadius + i * ringSpacing, 0, 2 * Math.PI);
          ctx.stroke();
        }
        ctx.restore();
      }

      if (node.id === 0 || currentState < 3) return;

      ctx.beginPath();
      ctx.arc(node.x, node.y, node.size, 0, 2 * Math.PI);
      ctx.fillStyle = node.color;
      ctx.globalAlpha = activeRadial === null || node.radialIndex === activeRadial ? 1 : 0.1;
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    function setState(state) {
      currentState = state;
      activeRadial = null;
      Graph.graphData(Graph.graphData());
    }

    function createCheckboxGroup(containerId, options, groupType) {
      const container = document.getElementById(containerId);
      options.forEach(opt => {
        const label = document.createElement('label');
        label.innerHTML = `<input type="checkbox" value="${opt}" data-group="${groupType}"> ${opt}`;
        container.appendChild(label);
      });
    }

    function getCheckedFilters(group) {
      return Array.from(document.querySelectorAll(`input[data-group="${group}"]:checked`)).map(el => el.value);
    }

    function applyFilters() {
      const selectedCategories = getCheckedFilters('category');
      const selectedImpacts = getCheckedFilters('impact');

      const radialToInclude = new Set();

  // Step 1: Find which radial lines match the filter
      nodes.forEach(n => {
    if (!n.name) return; // skip center node
    const catMatch = selectedCategories.length === 0 || selectedCategories.some(cat => n.categories.includes(cat));
    const impMatch = selectedImpacts.length === 0 || selectedImpacts.some(imp => n.impacts.includes(imp));
    if (catMatch && impMatch) {
      radialToInclude.add(n.radialIndex);
    }
  });

  // Step 2: Include all nodes (even intermediate) for matched radials
      const filteredNodes = nodes.filter(n =>
        n.id === centerNodeId || (n.radialIndex !== undefined && radialToInclude.has(n.radialIndex))
        );

      const filteredNodeIds = new Set(filteredNodes.map(n => n.id));

  // Step 3: Include links where both ends are still visible
      const filteredLinks = links.filter(link =>
        filteredNodeIds.has(link.source) && filteredNodeIds.has(link.target)
        );

      Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
    }


    createCheckboxGroup('category-filters', allCategories, 'category');
    createCheckboxGroup('impact-filters', allImpacts, 'impact');

    document.querySelectorAll('#filter-panel input').forEach(el =>
      el.addEventListener('change', applyFilters)
      );

    setState(3);
    applyFilters();
  </script>
</body>
</html>
