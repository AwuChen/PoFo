<!DOCTYPE html>
<html lang="en">
<head> 
  <style> 
    body { margin: 0; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
    }

    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
    }

    #legend h4 {
      margin-top: 0;
      font-size: 14px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
</head>

<body>
  <div id="controls">
    <button onclick="setState(1)">State 1: Lines Only</button>
    <button onclick="setState(2)">State 2: Grid Only</button>
    <button onclick="setState(3)">State 3: + Nodes</button>
  </div>

  <div id="legend">
    <h4>PORTFOLIO & CATEGORIES</h4>
    <div id="categoryFilters"></div>
  </div>

  <div id="impactLegend" style="margin-top: 20px;">
    <h4>IMPACT</h4>
    <div id="impactFilters"></div>
  </div>

  <div id="graph"></div>

  <script>
    const radialNames = [
      { name: 'URF / TX The BOX', category: 'Investment', impact: 'Retail' },
      { name: 'SAUVEREIGN', category: 'Investment', impact: 'Branding' },
      { name: 'DONGHAI', category: 'Forces', impact: 'East.West' },
      { name: 'EASTERN SEAS', category: 'Forces', impact: 'Strategy.Culture' },
      { name: 'DANDELION', category: 'Consultancies', impact: 'Edu.Learning.Collective' },
      { name: 'BILI Q', category: 'Cities.culture.art', impact: 'Creative Solution' },
      { name: 'KYOTO ART BANK', category: 'Ecosystems', impact: 'Edu.Learning.Collective' },
      { name: 'ARAMIS WINES', category: 'Yesteryears', impact: 'Branding' }
    ];


    const categories = [...new Set(radialNames.map(r => r.category))];
    const impacts = [...new Set(radialNames.map(r => r.impact))];
    let filteredCategories = new Set(categories);
    let filteredImpacts = new Set(impacts);

    const radialCount = radialNames.length;
    const maxLayers = 5;
    const ringSpacing = 80;
    const baseRadius = 100;
    const ringColors = ['#bc6c25', '#606c38', '#283618', '#dda15e', '#7b7b7b'];
    
    const nodes = [], links = [];
    const radialMaxLayer = [];
    let nodeId = 0;

    const centerNodeId = nodeId++;
    nodes.push({ id: centerNodeId, fx: 0, fy: 0, size: 4, color: '#000000' });

    for (let i = 0; i < radialCount; i++) {
      const nameData = radialNames[i];
      const thisMaxLayer = Math.floor(Math.random() * maxLayers) + 1;
      radialMaxLayer.push(thisMaxLayer);
      let lastNodeId = centerNodeId;

      for (let l = 0; l < thisMaxLayer; l++) {
        const angle = (2 * Math.PI * i) / radialCount;
        const radius = baseRadius + l * ringSpacing;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);

        nodes.push({
          id: nodeId,
          fx: x,
          fy: y,
          radialIndex: i,
          layer: l,
          name: nameData.name,
          category: nameData.category,
          size: Math.random() * 6 + 2,
          color: ringColors[l % ringColors.length]
        });

        links.push({
          source: lastNodeId,
          target: nodeId,
          radialIndex: i,
          category: nameData.category
        });

        lastNodeId = nodeId;
        nodeId++;
      }

      const angle = (2 * Math.PI * i) / radialCount;
      const radius = baseRadius + thisMaxLayer * ringSpacing + 20;
      const x = radius * Math.cos(angle);
      const y = radius * Math.sin(angle);

      nodes.push({
        id: nodeId,
        fx: x,
        fy: y,
        radialIndex: i,
        layer: thisMaxLayer,
        category: nameData.category,
        size: 0,
        color: 'transparent',
        invisible: true
      });

      links.push({
        source: lastNodeId,
        target: nodeId,
        radialIndex: i,
        category: nameData.category
      });

      nodeId++;
    }

    let filteredCategories = new Set(categories); // default to all visible
    const gData = { nodes, links };
    let currentState = 3;
    let activeRadial = null;

    const Graph = ForceGraph()(document.getElementById('graph'))
    .graphData(gData)
    .enableNodeDrag(false)
    .onEngineTick(() => Graph.pauseAnimation())
    linkWidth(link =>
      filteredCategories.has(link.category) &&
      filteredImpacts.has(link.impact) &&
      (currentState !== 2 || link.radialIndex === activeRadial) ? 2 : 0
      )
    .linkColor(link => filteredCategories.has(link.category) ? '#aaa' : 'transparent')
    .onNodeHover(node => {
      activeRadial = node ? node.radialIndex : null;
      Graph.graphData(gData);
    })
    .nodeCanvasObject((node, ctx, globalScale) => {
      if (node.id === 0 && currentState >= 2) {
        ctx.save();
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1 / globalScale;
        for (let i = 0; i < maxLayers; i++) {
          ctx.beginPath();
          ctx.arc(0, 0, baseRadius + i * ringSpacing, 0, 2 * Math.PI);
          ctx.stroke();
        }
        ctx.restore();
      }

      if (
        node.invisible || node.id === 0 || currentState < 3 ||
        !filteredCategories.has(node.category) || !filteredImpacts.has(node.impact)
        ) return;

        const isHighlighted = node.radialIndex === activeRadial;
      ctx.beginPath();
      ctx.arc(node.x, node.y, node.size, 0, 2 * Math.PI);
      ctx.fillStyle = node.color;
      ctx.globalAlpha = isHighlighted || activeRadial === null ? 1 : 0.1;
      ctx.fill();
      ctx.globalAlpha = 1;
    });

    function setState(state) {
      currentState = state;
      activeRadial = null;
      Graph.graphData(gData);
    }

    function buildLegend() {
      const container = document.getElementById('categoryFilters');
      categories.forEach(category => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.marginBottom = '5px';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.onchange = () => {
          if (checkbox.checked) {
            filteredCategories.add(category);
          } else {
            filteredCategories.delete(category);
          }
          Graph.graphData(gData);
        };

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(' ' + category));
        container.appendChild(label);
      });
    }

    function buildImpactLegend() {
      const container = document.getElementById('impactFilters');
      impacts.forEach(impact => {
        const label = document.createElement('label');
        label.style.display = 'block';
        label.style.marginBottom = '5px';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.checked = true;
        checkbox.onchange = () => {
          if (checkbox.checked) {
            filteredImpacts.add(impact);
          } else {
            filteredImpacts.delete(impact);
          }
          Graph.graphData(gData);
        };

        label.appendChild(checkbox);
        label.appendChild(document.createTextNode(' ' + impact));
        container.appendChild(label);
      });
    }

    buildLegend();
    buildImpactLegend();
    setState(1);
  </script>
</body>
</html>
