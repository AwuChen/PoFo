<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      max-height: 90vh;
      overflow-y: auto;
    }
    #controls h3 {
      margin-top: 10px;
      margin-bottom: 5px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
</head>
<body>
  <div id="controls">
    <h3>PORTFOLIO & CATEGORIES</h3>
    <div id="categoryFilters"></div>
    <h3>APPROACH & IMPACT</h3>
    <div id="impactFilters"></div>
  </div>
  <div id="graph"></div>

  <script>
    const entities = [
      { name: 'URF / TX The BOX', categories: ['Investment'], impacts: ['Retail'] },
      { name: 'SAUVEREIGN', categories: ['Forces'], impacts: ['Branding', 'Retail'] },
      { name: 'DONGHAI', categories: ['Cities.culture.art'], impacts: ['East.West', 'Strategy.Culture'] },
      { name: 'EASTERN SEAS', categories: ['Consultancies'], impacts: ['Creative Solution'] },
      { name: 'DANDELION', categories: ['Yesteryears'], impacts: ['Strategy.Culture', 'Edu.Learning.Collective'] },
      { name: 'BILI Q', categories: ['Investment'], impacts: ['East.West'] },
      { name: 'KYOTO ART BANK', categories: ['Ecosystems'], impacts: ['Culture', 'Creative Solution'] },
      { name: 'ARAMIS WINES', categories: ['Yesteryears'], impacts: ['Branding'] }
    ];

    const impactRingMap = {
      'Strategy.Culture': 0,
      'Branding': 1,
      'Retail': 2,
      'East.West': 3,
      'Edu.Learning.Collective': 4,
      'Creative Solution': 5
    };

    const ringSpacing = 80;
    const baseRadius = 100;
    const ringColors = ['#bc6c25', '#606c38', '#283618', '#dda15e', '#7b7b7b', '#8ecae6'];
    const maxLayers = 6;

    let nodeId = 0;
    const nodes = [], links = [];

    const centerNodeId = nodeId++;
    nodes.push({ id: centerNodeId, fx: 0, fy: 0, size: 4, color: '#000000' });

    entities.forEach((entity, index) => {
      const angle = (2 * Math.PI * index) / entities.length;
      let lastNodeId = centerNodeId;

      entity.impacts.forEach(impact => {
        const ringIndex = impactRingMap[impact] ?? 0;
        const radius = baseRadius + ringIndex * ringSpacing;
        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);

        const thisNodeId = nodeId++;
        nodes.push({
          id: thisNodeId,
          fx: x,
          fy: y,
          name: entity.name,
          categories: entity.categories,
          impact: impact,
          radialIndex: index,
          size: 6,
          color: ringColors[ringIndex % ringColors.length]
        });

        links.push({
          source: lastNodeId,
          target: thisNodeId,
          radialIndex: index
        });

        lastNodeId = thisNodeId;
      });
    });

    const gData = { nodes, links };
    const Graph = ForceGraph()(document.getElementById('graph'))
      .graphData(gData)
      .enableNodeDrag(false)
      .linkDirectionalParticles(0)
      .linkWidth(() => 2)
      .linkColor(() => '#aaa')
      .nodeCanvasObject((node, ctx) => {
       if (node.id === centerNodeId) {
          // Draw rings
          ctx.save();
          ctx.strokeStyle = '#ddd';
          ctx.lineWidth = 1;
          for (let i = 0; i < maxLayers; i++) {
            ctx.beginPath();
            ctx.arc(0, 0, baseRadius + i * ringSpacing, 0, 2 * Math.PI);
            ctx.stroke();
          }
          ctx.restore();
          return;
        }
      });

    // Filters UI
    const allCategories = [...new Set(entities.flatMap(e => e.categories))];
    const allImpacts = [...new Set(entities.flatMap(e => e.impacts))];

    function createCheckbox(filterType, value) {
      const label = document.createElement('label');
      label.style.display = 'block';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = value;
      checkbox.name = filterType;
      checkbox.onchange = applyFilters;
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + value));
      return label;
    }

    const categoryDiv = document.getElementById('categoryFilters');
    allCategories.forEach(cat => categoryDiv.appendChild(createCheckbox('category', cat)));

    const impactDiv = document.getElementById('impactFilters');
    allImpacts.forEach(imp => impactDiv.appendChild(createCheckbox('impact', imp)));

    function getCheckedFilters(name) {
      return [...document.querySelectorAll(`input[name="${name}"]:checked`)].map(cb => cb.value);
    }

    function applyFilters() {
      const selectedCategories = getCheckedFilters('category');
      const selectedImpacts = getCheckedFilters('impact');

      const radialToInclude = new Set();

      nodes.forEach(n => {
        if (!n.name) return;
        const catMatch = selectedCategories.length === 0 || selectedCategories.some(cat => n.categories.includes(cat));
        const impMatch = selectedImpacts.length === 0 || selectedImpacts.includes(n.impact);
        if (catMatch && impMatch) {
          radialToInclude.add(n.radialIndex);
        }
      });

      const filteredNodes = nodes.filter(n =>
        n.id === centerNodeId || (n.radialIndex !== undefined && radialToInclude.has(n.radialIndex))
      );

      const nodeMap = new Map(filteredNodes.map(n => [n.id, n]));

      const filteredLinks = links
        .filter(link => nodeMap.has(link.source.id ?? link.source) && nodeMap.has(link.target.id ?? link.target))
        .map(link => ({
          source: nodeMap.get(link.source.id ?? link.source),
          target: nodeMap.get(link.target.id ?? link.target),
          radialIndex: link.radialIndex
        }));

      Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
    }
  </script>
</body>
</html>
