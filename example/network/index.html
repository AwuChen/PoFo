<!-- This is your modified full code -->
<!DOCTYPE html>
<html lang="en">
<head>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; position: absolute; top: 0; left: 0; z-index: 0; }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      z-index: 10;
      background: rgba(255,255,255,0.95);
      padding: 10px;
      border-radius: 8px;
      font-family: sans-serif;
      max-height: 90vh;
      overflow-y: auto;
    }
    #controls h3 {
      margin-top: 10px;
      margin-bottom: 5px;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/force-graph"></script>
</head>
<body>
  <div id="controls">
    <h3>PORTFOLIO & CATEGORIES</h3>
    <div id="categoryFilters"></div>
    <h3>APPROACH & IMPACT</h3>
    <div id="impactFilters"></div>
  </div>
  <div id="graph"></div>

  <script>
    const entities = [/*... your entity list here ...*/];

    const impactRingMap = {
      'Strategy.Culture': 0,
      'Branding': 1,
      'Retail': 2,
      'East.West': 3,
      'Edu.Learning.Collective': 4,
      'Creative Solution': 5
    };

    const ringSpacing = 80;
    const baseRadius = 100;
    const ringColors = ['#bc6c25', '#606c38', '#283618', '#dda15e', '#7b7b7b', '#8ecae6'];
    const maxLayers = 6;

    let nodeId = 0;
    const nodes = [], links = [];

    const centerNodeId = nodeId++;
    nodes.push({ id: centerNodeId, fx: 0, fy: 0, size: 4, color: '#000000' });

    entities.forEach((entity, index) => {
      const angle = (2 * Math.PI * index) / entities.length;
      let lastNodeId = centerNodeId;
      let furthestRadius = 0;

      entity.impacts.forEach(impact => {
        const ringIndex = impactRingMap[impact] ?? 0;
        const radius = baseRadius + ringIndex * ringSpacing;
        if (radius > furthestRadius) furthestRadius = radius;

        const x = radius * Math.cos(angle);
        const y = radius * Math.sin(angle);

        const thisNodeId = nodeId++;
        nodes.push({
          id: thisNodeId,
          fx: x,
          fy: y,
          name: entity.name,
          categories: entity.categories,
          impact: impact,
          radialIndex: index,
          size: 6,
          color: ringColors[ringIndex % ringColors.length]
        });

        links.push({
          source: lastNodeId,
          target: thisNodeId,
          radialIndex: index
        });

        lastNodeId = thisNodeId;
      });

      // Add invisible tip node to extend the radial line
      const tipRadius = furthestRadius + 20;
      const tipX = tipRadius * Math.cos(angle);
      const tipY = tipRadius * Math.sin(angle);

      const tipNodeId = nodeId++;
      nodes.push({
        id: tipNodeId,
        fx: tipX,
        fy: tipY,
        radialIndex: index,
        size: 0,
        color: 'rgba(0,0,0,0)', // Invisible
        isTip: true
      });

      links.push({
        source: lastNodeId,
        target: tipNodeId,
        radialIndex: index
      });
    });

    const gData = { nodes, links };
    const Graph = ForceGraph()(document.getElementById('graph'))
    .graphData(gData)
    .enableNodeDrag(false)
    .linkDirectionalParticles(0)
    .linkWidth(() => 0.5)
    .linkColor(() => '#000000')
    .nodeCanvasObject((node, ctx, globalScale) => {
      if (node.id === centerNodeId) {
        ctx.save();
        ctx.translate(node.x, node.y);
        ctx.strokeStyle = '#ddd';
        ctx.lineWidth = 1;
        for (let i = 0; i < maxLayers; i++) {
          ctx.beginPath();
          ctx.arc(0, 0, baseRadius + i * ringSpacing, 0, 2 * Math.PI);
          ctx.stroke();
        }
        ctx.restore();
      } else if (!node.isTip) {
        const size = node.size || 4;
        ctx.beginPath();
        ctx.arc(node.x, node.y, size, 0, 2 * Math.PI, false);
        ctx.fillStyle = node.color || '#666';
        ctx.fill();
      }
    });

    // Filters UI
    const allCategories = [...new Set(entities.flatMap(e => e.categories))];
    const allImpacts = [...new Set(entities.flatMap(e => e.impacts))];

    function createCheckbox(filterType, value) {
      const label = document.createElement('label');
      label.style.display = 'block';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.value = value;
      checkbox.name = filterType;
      checkbox.onchange = applyFilters;
      label.appendChild(checkbox);
      label.appendChild(document.createTextNode(' ' + value));
      return label;
    }

    const categoryDiv = document.getElementById('categoryFilters');
    allCategories.forEach(cat => categoryDiv.appendChild(createCheckbox('category', cat)));

    const impactDiv = document.getElementById('impactFilters');
    allImpacts.forEach(imp => impactDiv.appendChild(createCheckbox('impact', imp)));

    function getCheckedFilters(name) {
      return [...document.querySelectorAll(`input[name="${name}"]:checked`)].map(cb => cb.value);
    }

    function applyFilters() {
      const selectedCategories = getCheckedFilters('category');
      const selectedImpacts = getCheckedFilters('impact');

      const radialToInclude = new Set();

      nodes.forEach(n => {
        if (!n.name) return;
        const catMatch = selectedCategories.length === 0 || selectedCategories.some(cat => n.categories.includes(cat));
        const impMatch = selectedImpacts.length === 0 || selectedImpacts.includes(n.impact);
        if (catMatch && impMatch) {
          radialToInclude.add(n.radialIndex);
        }
      });

      const filteredNodes = nodes.filter(n =>
        n.id === centerNodeId || (n.radialIndex !== undefined && radialToInclude.has(n.radialIndex))
      );

      const nodeMap = new Map(filteredNodes.map(n => [n.id, n]));
      const filteredLinks = links.filter(l => nodeMap.has(l.source) && nodeMap.has(l.target));

      Graph.graphData({ nodes: filteredNodes, links: filteredLinks });
    }
  </script>
</body>
</html>
